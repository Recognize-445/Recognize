% Input: 224x224x3
face_identification_nn.layers = {};

%Conv layer 1: filterdim = 3x3, num_filters = 64, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 3, 64, 'single'), initB*randn(1, 64, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 2: filterdim = 3x3, num_filters = 64, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 64, 64, 'single'), initB*randn(1, 64, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%MaxPool: dim 2x2, stride=2, pad=0
face_identification_nn.layers{end + 1} = ...
struct(...
'type', 'pool', ...
'method', 'max', ...
'pool', [2 2], 'stride', 2, 'pad', 0);

%Conv layer 3: filterdim = 3x3, num_filters = 128, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 64, 128, 'single'), initB*randn(1, 128, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 4: filterdim = 3x3, num_filters = 128, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 128, 128, 'single'), initB*randn(1, 128, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%MaxPool: dim 2x2, stride=2, pad=0
face_identification_nn.layers{end + 1} = ...
struct(...
'type', 'pool', ...
'method', 'max', ...
'pool', [2 2], 'stride', 2, 'pad', 0);

%Conv layer 5: filterdim = 3x3, num_filters = 256, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 128, 256, 'single'), initB*randn(1, 256, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 6: filterdim = 3x3, num_filters = 256, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 256, 256, 'single'), initB*randn(1, 256, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 7: filterdim = 3x3, num_filters = 256, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 256, 256, 'single'), initB*randn(1, 256, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%MaxPool: dim 2x2, stride=2, pad=0
face_identification_nn.layers{end + 1} = ...
struct(...
'type', 'pool', ...
'method', 'max', ...
'pool', [2 2], 'stride', 2, 'pad', 0);

%Conv layer 8: filterdim = 3x3, num_filters = 512, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 256, 512, 'single'), initB*randn(1, 512, 'single')}}, ...
'stride', 1, ...
'pad', 1);

% -------------------------- Cutting the network because we don't have
% enough training data.

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 9: filterdim = 3x3, num_filters = 512, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 512, 512, 'single'), initB*randn(1, 512, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 10: filterdim = 3x3, num_filters = 512, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 512, 512, 'single'), initB*randn(1, 512, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%MaxPool: dim 2x2, stride=2, pad=0
face_identification_nn.layers{end + 1} = ...
struct(...
'type', 'pool', ...
'method', 'max', ...
'pool', [2 2], 'stride', 2, 'pad', 0);

%Conv layer 11: filterdim = 3x3, num_filters = 512, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 512, 512, 'single'), initB*randn(1, 512, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 12: filterdim = 3x3, num_filters = 512, stride=1, pad=1
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(3, 3, 512, 512, 'single'), initB*randn(1, 512, 'single')}}, ...
'stride', 1, ...
'pad', 1);

%-------- endcut -----------%



%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%MaxPool: dim 2x2, stride=2, pad=0
face_identification_nn.layers{end + 1} = ...
struct(...
'type', 'pool', ...
'method', 'max', ...
'pool', [2 2], 'stride', 2, 'pad', 0);

%Conv layer 9: filterdim = 7x7, num_filters = 4096, stride=1, pad=0
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(7, 7, 512, 4096, 'single'), initB*randn(1, 4096, 'single')}}, ...
'stride', 1, ...
'pad', 0);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

%Conv layer 10: filterdim = 1x1, num_filters = 4096, stride=1, pad=0
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(1, 1, 4096, 4096, 'single'), initB*randn(1, 4096, 'single')}}, ...
'stride', 1, ...
'pad', 0);

%RELU
face_identification_nn.layers{end + 1} = struct('type', 'relu');

% Note: The output filters should be set to however many people we have for
% training.
%Conv layer 11: filterdim = 1x1, num_filters = CHANGE THIS, stride=1, pad=0
face_identification_nn.layers{end + 1} = ...
struct( ...
'type', 'conv', ...
'weights', {{initW * randn(1, 1, 4096, 7, 'single'), initB*randn(1, 7, 'single')}}, ...
'stride', 1, ...
'pad', 0);

% Softmax with log loss
face_identification_nn.layers{end + 1} = struct('type', 'softmaxloss');